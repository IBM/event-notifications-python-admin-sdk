# coding: utf-8

# (C) Copyright IBM Corp. 2021.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.42.0-8746aaa4-20211102-213344
 
"""
No description provided (generated by Openapi Generator
https://github.com/openapitools/openapi-generator)

API Version: 1.0
"""

from datetime import datetime
from enum import Enum
from typing import Dict, List
import json

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################

class EventNotificationsV1(BaseService):
    """The Event Notifications V1 service."""

    DEFAULT_SERVICE_URL = 'https://us-south.event-notifications.cloud.ibm.com/event-notifications'
    DEFAULT_SERVICE_NAME = 'event_notifications'

    @classmethod
    def new_instance(cls,
                     service_name: str = DEFAULT_SERVICE_NAME,
                    ) -> 'EventNotificationsV1':
        """
        Return a new client for the Event Notifications service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    def __init__(self,
                 authenticator: Authenticator = None,
                ) -> None:
        """
        Construct a new client for the Event Notifications service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/main/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self,
                             service_url=self.DEFAULT_SERVICE_URL,
                             authenticator=authenticator)


    #########################
    # Sources
    #########################


    def list_sources(self,
        instance_id: str,
        *,
        limit: int = None,
        offset: int = None,
        search: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List all Sources.

        List all Sources.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param int limit: (optional) Page limit for paginated results.
        :param int offset: (optional) offset for paginated results.
        :param str search: (optional) Search string for filtering results.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SourceList` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_sources')
        headers.update(sdk_headers)

        params = {
            'limit': limit,
            'offset': offset,
            'search': search
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/sources'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request, **kwargs)
        return response


    def get_source(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get a Source.

        Get a Sources.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Source.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Source` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_source')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/sources/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Topics
    #########################


    def create_topic(self,
        instance_id: str,
        name: str,
        *,
        description: str = None,
        sources: List['TopicUpdateSourcesItem'] = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create a new Topic.

        Create a new Topic.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str name: Name of the topic.
        :param str description: (optional) Description of the topic.
        :param List[TopicUpdateSourcesItem] sources: (optional) List of sources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TopicResponse` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if sources is not None:
            sources = [convert_model(x) for x in sources]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_topic')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'sources': sources
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/topics'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_topics(self,
        instance_id: str,
        *,
        limit: int = None,
        offset: int = None,
        search: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List all Topics.

        List all Topics.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param int limit: (optional) Page limit for paginated results.
        :param int offset: (optional) offset for paginated results.
        :param str search: (optional) Search string for filtering results.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TopicList` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_topics')
        headers.update(sdk_headers)

        params = {
            'limit': limit,
            'offset': offset,
            'search': search
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/topics'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request, **kwargs)
        return response


    def get_topic(self,
        instance_id: str,
        id: str,
        *,
        include: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get details of a Topic.

        Get details of a Topic.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Topic.
        :param str include: (optional) Include sub topics.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Topic` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_topic')
        headers.update(sdk_headers)

        params = {
            'include': include
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/topics/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request, **kwargs)
        return response


    def replace_topic(self,
        instance_id: str,
        id: str,
        *,
        name: str = None,
        description: str = None,
        sources: List['TopicUpdateSourcesItem'] = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update details of a Topic.

        Update details of a Topic.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Topic.
        :param str name: (optional) Name of the topic.
        :param str description: (optional) Description of the topic.
        :param List[TopicUpdateSourcesItem] sources: (optional) List of sources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Topic` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        if sources is not None:
            sources = [convert_model(x) for x in sources]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='replace_topic')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'sources': sources
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/topics/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def delete_topic(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a Topic.

        Delete a Topic.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Topic.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_topic')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/topics/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Destinations
    #########################


    def create_destination(self,
        instance_id: str,
        name: str,
        type: str,
        *,
        description: str = None,
        config: 'DestinationConfig' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create a new Destination.

        Create a new Destination.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str name: The Destintion name.
        :param str type: The type of Destination Webhook.
        :param str description: (optional) The Destination description.
        :param DestinationConfig config: (optional) Payload describing a
               destination configuration.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `DestinationResponse` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if type is None:
            raise ValueError('type must be provided')
        if config is not None:
            config = convert_model(config)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_destination')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'type': type,
            'description': description,
            'config': config
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/destinations'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_destinations(self,
        instance_id: str,
        *,
        limit: int = None,
        offset: int = None,
        search: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List all Destinations.

        List all Destinations.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param int limit: (optional) Page limit for paginated results.
        :param int offset: (optional) offset for paginated results.
        :param str search: (optional) Search string for filtering results.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `DestinationList` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_destinations')
        headers.update(sdk_headers)

        params = {
            'limit': limit,
            'offset': offset,
            'search': search
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/destinations'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request, **kwargs)
        return response


    def get_destination(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get details of a Destination.

        Get details of a Destination.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Destination.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Destination` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_destination')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/destinations/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_destination(self,
        instance_id: str,
        id: str,
        *,
        name: str = None,
        description: str = None,
        config: 'DestinationConfig' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update details of a Destination.

        Update details of a Destination.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Destination.
        :param str name: (optional) Destination name.
        :param str description: (optional) Destination description.
        :param DestinationConfig config: (optional) Payload describing a
               destination configuration.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Destination` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        if config is not None:
            config = convert_model(config)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_destination')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'config': config
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/destinations/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def delete_destination(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a Destination.

        Delete a Destination.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Destination.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_destination')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/destinations/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Subscriptions
    #########################


    def create_subscription(self,
        instance_id: str,
        name: str,
        destination_id: str,
        topic_id: str,
        attributes: 'SubscriptionCreateAttributes',
        *,
        description: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create a new Subscription.

        Create a new Subscription.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str name: Subscription name.
        :param str destination_id: Destination ID.
        :param str topic_id: Topic ID.
        :param SubscriptionCreateAttributes attributes:
        :param str description: (optional) Subscription description.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Subscription` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if destination_id is None:
            raise ValueError('destination_id must be provided')
        if topic_id is None:
            raise ValueError('topic_id must be provided')
        if attributes is None:
            raise ValueError('attributes must be provided')
        attributes = convert_model(attributes)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_subscription')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'destination_id': destination_id,
            'topic_id': topic_id,
            'attributes': attributes,
            'description': description
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/subscriptions'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_subscriptions(self,
        instance_id: str,
        *,
        offset: int = None,
        limit: int = None,
        search: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List all Subscriptions.

        List all Subscriptions.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param int offset: (optional) offset for paginated results.
        :param int limit: (optional) Page limit for paginated results.
        :param str search: (optional) Search string for filtering results.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SubscriptionList` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_subscriptions')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'search': search
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id']
        path_param_values = self.encode_path_vars(instance_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/subscriptions'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request, **kwargs)
        return response


    def get_subscription(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get details of a Subscription.

        Get details of a Subscription.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Subscription.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Subscription` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_subscription')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/subscriptions/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def delete_subscription(self,
        instance_id: str,
        id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a Subscription.

        Delete a Subscription.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Subscription.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_subscription')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/subscriptions/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_subscription(self,
        instance_id: str,
        id: str,
        *,
        name: str = None,
        description: str = None,
        attributes: 'SubscriptionUpdateAttributes' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update details of a Subscription.

        Update details of a Subscription.

        :param str instance_id: Unique identifier for IBM Cloud Event Notifications
               instance.
        :param str id: Unique identifier for Subscription.
        :param str name: (optional) Name of the subscription.
        :param str description: (optional) Description of the subscription.
        :param SubscriptionUpdateAttributes attributes: (optional)
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Subscription` object
        """

        if instance_id is None:
            raise ValueError('instance_id must be provided')
        if id is None:
            raise ValueError('id must be provided')
        if attributes is not None:
            attributes = convert_model(attributes)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_subscription')
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'attributes': attributes
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['instance_id', 'id']
        path_param_values = self.encode_path_vars(instance_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/instances/{instance_id}/subscriptions/{id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


##############################################################################
# Models
##############################################################################


class Destination():
    """
    Payload describing a destination get request.

    :attr str id: Destination ID.
    :attr str name: Destination name.
    :attr str description: Destination description.
    :attr str type: Destination type Email/SMS/Webhook.
    :attr DestinationConfig config: (optional) Payload describing a destination
          configuration.
    :attr datetime updated_at: Last updated time.
    :attr int subscription_count: Number of subscriptions.
    :attr List[str] subscription_names: List of subscriptions.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 type: str,
                 updated_at: datetime,
                 subscription_count: int,
                 subscription_names: List[str],
                 *,
                 config: 'DestinationConfig' = None) -> None:
        """
        Initialize a Destination object.

        :param str id: Destination ID.
        :param str name: Destination name.
        :param str description: Destination description.
        :param str type: Destination type Email/SMS/Webhook.
        :param datetime updated_at: Last updated time.
        :param int subscription_count: Number of subscriptions.
        :param List[str] subscription_names: List of subscriptions.
        :param DestinationConfig config: (optional) Payload describing a
               destination configuration.
        """
        self.id = id
        self.name = name
        self.description = description
        self.type = type
        self.config = config
        self.updated_at = updated_at
        self.subscription_count = subscription_count
        self.subscription_names = subscription_names

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Destination':
        """Initialize a Destination object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in Destination JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Destination JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in Destination JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in Destination JSON')
        if 'config' in _dict:
            args['config'] = DestinationConfig.from_dict(_dict.get('config'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in Destination JSON')
        if 'subscription_count' in _dict:
            args['subscription_count'] = _dict.get('subscription_count')
        else:
            raise ValueError('Required property \'subscription_count\' not present in Destination JSON')
        if 'subscription_names' in _dict:
            args['subscription_names'] = _dict.get('subscription_names')
        else:
            raise ValueError('Required property \'subscription_names\' not present in Destination JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Destination object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'config') and self.config is not None:
            _dict['config'] = self.config.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'subscription_count') and self.subscription_count is not None:
            _dict['subscription_count'] = self.subscription_count
        if hasattr(self, 'subscription_names') and self.subscription_names is not None:
            _dict['subscription_names'] = self.subscription_names
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Destination object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Destination') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Destination') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Destination type Email/SMS/Webhook.
        """
        WEBHOOK = 'webhook'
        SMTP_IBM = 'smtp_ibm'
        SMS_IBM = 'sms_ibm'


class DestinationConfig():
    """
    Payload describing a destination configuration.

    :attr DestinationConfigParams params:
    """

    def __init__(self,
                 params: 'DestinationConfigParams') -> None:
        """
        Initialize a DestinationConfig object.

        :param DestinationConfigParams params:
        """
        self.params = params

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DestinationConfig':
        """Initialize a DestinationConfig object from a json dictionary."""
        args = {}
        if 'params' in _dict:
            args['params'] = _dict.get('params')
        else:
            raise ValueError('Required property \'params\' not present in DestinationConfig JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DestinationConfig object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'params') and self.params is not None:
            if isinstance(self.params, dict):
                _dict['params'] = self.params
            else:
                _dict['params'] = self.params.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DestinationConfig object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DestinationConfig') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DestinationConfig') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DestinationConfigParams():
    """
    DestinationConfigParams.

    """

    def __init__(self) -> None:
        """
        Initialize a DestinationConfigParams object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
                  ", ".join(['DestinationConfigParamsWebhookDestinationConfig']))
        raise Exception(msg)

class DestinationLisItem():
    """
    Destination object.

    :attr str id: Destination ID.
    :attr str name: Destination name.
    :attr str description: Destination description.
    :attr str type: Destination type Email/SMS/Webhook.
    :attr int subscription_count: Subscription count.
    :attr List[str] subscription_names: Names of subscriptions.
    :attr datetime updated_at: Updated at.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 type: str,
                 subscription_count: int,
                 subscription_names: List[str],
                 updated_at: datetime) -> None:
        """
        Initialize a DestinationLisItem object.

        :param str id: Destination ID.
        :param str name: Destination name.
        :param str description: Destination description.
        :param str type: Destination type Email/SMS/Webhook.
        :param int subscription_count: Subscription count.
        :param List[str] subscription_names: Names of subscriptions.
        :param datetime updated_at: Updated at.
        """
        self.id = id
        self.name = name
        self.description = description
        self.type = type
        self.subscription_count = subscription_count
        self.subscription_names = subscription_names
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DestinationLisItem':
        """Initialize a DestinationLisItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in DestinationLisItem JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in DestinationLisItem JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in DestinationLisItem JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in DestinationLisItem JSON')
        if 'subscription_count' in _dict:
            args['subscription_count'] = _dict.get('subscription_count')
        else:
            raise ValueError('Required property \'subscription_count\' not present in DestinationLisItem JSON')
        if 'subscription_names' in _dict:
            args['subscription_names'] = _dict.get('subscription_names')
        else:
            raise ValueError('Required property \'subscription_names\' not present in DestinationLisItem JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in DestinationLisItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DestinationLisItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'subscription_count') and self.subscription_count is not None:
            _dict['subscription_count'] = self.subscription_count
        if hasattr(self, 'subscription_names') and self.subscription_names is not None:
            _dict['subscription_names'] = self.subscription_names
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DestinationLisItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DestinationLisItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DestinationLisItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Destination type Email/SMS/Webhook.
        """
        WEBHOOK = 'webhook'
        SMTP_IBM = 'smtp_ibm'
        SMS_IBM = 'sms_ibm'


class DestinationList():
    """
    Payload describing a destination list request.

    :attr int total_count: Total number of destinations.
    :attr int offset: Current offset.
    :attr int limit: limit to show destinations.
    :attr List[DestinationLisItem] destinations: List of destinations.
    """

    def __init__(self,
                 total_count: int,
                 offset: int,
                 limit: int,
                 destinations: List['DestinationLisItem']) -> None:
        """
        Initialize a DestinationList object.

        :param int total_count: Total number of destinations.
        :param int offset: Current offset.
        :param int limit: limit to show destinations.
        :param List[DestinationLisItem] destinations: List of destinations.
        """
        self.total_count = total_count
        self.offset = offset
        self.limit = limit
        self.destinations = destinations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DestinationList':
        """Initialize a DestinationList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in DestinationList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in DestinationList JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in DestinationList JSON')
        if 'destinations' in _dict:
            args['destinations'] = [DestinationLisItem.from_dict(x) for x in _dict.get('destinations')]
        else:
            raise ValueError('Required property \'destinations\' not present in DestinationList JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DestinationList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'destinations') and self.destinations is not None:
            _dict['destinations'] = [x.to_dict() for x in self.destinations]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DestinationList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DestinationList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DestinationList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DestinationResponse():
    """
    Payload describing a destination get request.

    :attr str id: Destination ID.
    :attr str name: Destination name.
    :attr str description: Destination description.
    :attr str type: Destination type Email/SMS/Webhook.
    :attr DestinationConfig config: Payload describing a destination configuration.
    :attr datetime created_at: Last updated time.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 type: str,
                 config: 'DestinationConfig',
                 created_at: datetime) -> None:
        """
        Initialize a DestinationResponse object.

        :param str id: Destination ID.
        :param str name: Destination name.
        :param str description: Destination description.
        :param str type: Destination type Email/SMS/Webhook.
        :param DestinationConfig config: Payload describing a destination
               configuration.
        :param datetime created_at: Last updated time.
        """
        self.id = id
        self.name = name
        self.description = description
        self.type = type
        self.config = config
        self.created_at = created_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DestinationResponse':
        """Initialize a DestinationResponse object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in DestinationResponse JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in DestinationResponse JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in DestinationResponse JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in DestinationResponse JSON')
        if 'config' in _dict:
            args['config'] = DestinationConfig.from_dict(_dict.get('config'))
        else:
            raise ValueError('Required property \'config\' not present in DestinationResponse JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in DestinationResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DestinationResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'config') and self.config is not None:
            _dict['config'] = self.config.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DestinationResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DestinationResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DestinationResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Destination type Email/SMS/Webhook.
        """
        WEBHOOK = 'webhook'


class Rules():
    """
    Rule object.

    :attr bool enabled: (optional) Whether the rule is enabled or not.
    :attr str event_type_filter: Event type filter.
    :attr str notification_filter: (optional) Notification filter.
    """

    def __init__(self,
                 event_type_filter: str,
                 *,
                 enabled: bool = None,
                 notification_filter: str = None) -> None:
        """
        Initialize a Rules object.

        :param str event_type_filter: Event type filter.
        :param bool enabled: (optional) Whether the rule is enabled or not.
        :param str notification_filter: (optional) Notification filter.
        """
        self.enabled = enabled
        self.event_type_filter = event_type_filter
        self.notification_filter = notification_filter

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Rules':
        """Initialize a Rules object from a json dictionary."""
        args = {}
        if 'enabled' in _dict:
            args['enabled'] = _dict.get('enabled')
        if 'event_type_filter' in _dict:
            args['event_type_filter'] = _dict.get('event_type_filter')
        else:
            raise ValueError('Required property \'event_type_filter\' not present in Rules JSON')
        if 'notification_filter' in _dict:
            args['notification_filter'] = _dict.get('notification_filter')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Rules object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'enabled') and self.enabled is not None:
            _dict['enabled'] = self.enabled
        if hasattr(self, 'event_type_filter') and self.event_type_filter is not None:
            _dict['event_type_filter'] = self.event_type_filter
        if hasattr(self, 'notification_filter') and self.notification_filter is not None:
            _dict['notification_filter'] = self.notification_filter
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Rules object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Rules') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Rules') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class RulesGet():
    """
    Rule object.

    :attr bool enabled: Whether the rule is enabled or not.
    :attr str event_type_filter: Event type filter.
    :attr str notification_filter: Notification filter.
    :attr str updated_at: Last time the topic was updated.
    :attr str id: Autogenerated rule ID.
    """

    def __init__(self,
                 enabled: bool,
                 event_type_filter: str,
                 notification_filter: str,
                 updated_at: str,
                 id: str) -> None:
        """
        Initialize a RulesGet object.

        :param bool enabled: Whether the rule is enabled or not.
        :param str event_type_filter: Event type filter.
        :param str notification_filter: Notification filter.
        :param str updated_at: Last time the topic was updated.
        :param str id: Autogenerated rule ID.
        """
        self.enabled = enabled
        self.event_type_filter = event_type_filter
        self.notification_filter = notification_filter
        self.updated_at = updated_at
        self.id = id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'RulesGet':
        """Initialize a RulesGet object from a json dictionary."""
        args = {}
        if 'enabled' in _dict:
            args['enabled'] = _dict.get('enabled')
        else:
            raise ValueError('Required property \'enabled\' not present in RulesGet JSON')
        if 'event_type_filter' in _dict:
            args['event_type_filter'] = _dict.get('event_type_filter')
        else:
            raise ValueError('Required property \'event_type_filter\' not present in RulesGet JSON')
        if 'notification_filter' in _dict:
            args['notification_filter'] = _dict.get('notification_filter')
        else:
            raise ValueError('Required property \'notification_filter\' not present in RulesGet JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = _dict.get('updated_at')
        else:
            raise ValueError('Required property \'updated_at\' not present in RulesGet JSON')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in RulesGet JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a RulesGet object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'enabled') and self.enabled is not None:
            _dict['enabled'] = self.enabled
        if hasattr(self, 'event_type_filter') and self.event_type_filter is not None:
            _dict['event_type_filter'] = self.event_type_filter
        if hasattr(self, 'notification_filter') and self.notification_filter is not None:
            _dict['notification_filter'] = self.notification_filter
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = self.updated_at
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this RulesGet object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'RulesGet') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'RulesGet') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Source():
    """
    Payload describing a source generate request.

    :attr str id: The id of the source.
    :attr str name: The name of the source.
    :attr str description: The description of the source.
    :attr bool enabled: The status of the source.
    :attr str type: Type of the source.
    :attr datetime updated_at: The last updated time of the source.
    :attr int topic_count: The number of topics.
    :attr List[str] topic_names: The names of the topics.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 enabled: bool,
                 type: str,
                 updated_at: datetime,
                 topic_count: int,
                 topic_names: List[str]) -> None:
        """
        Initialize a Source object.

        :param str id: The id of the source.
        :param str name: The name of the source.
        :param str description: The description of the source.
        :param bool enabled: The status of the source.
        :param str type: Type of the source.
        :param datetime updated_at: The last updated time of the source.
        :param int topic_count: The number of topics.
        :param List[str] topic_names: The names of the topics.
        """
        self.id = id
        self.name = name
        self.description = description
        self.enabled = enabled
        self.type = type
        self.updated_at = updated_at
        self.topic_count = topic_count
        self.topic_names = topic_names

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Source':
        """Initialize a Source object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in Source JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Source JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in Source JSON')
        if 'enabled' in _dict:
            args['enabled'] = _dict.get('enabled')
        else:
            raise ValueError('Required property \'enabled\' not present in Source JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in Source JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in Source JSON')
        if 'topic_count' in _dict:
            args['topic_count'] = _dict.get('topic_count')
        else:
            raise ValueError('Required property \'topic_count\' not present in Source JSON')
        if 'topic_names' in _dict:
            args['topic_names'] = _dict.get('topic_names')
        else:
            raise ValueError('Required property \'topic_names\' not present in Source JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Source object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'enabled') and self.enabled is not None:
            _dict['enabled'] = self.enabled
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'topic_count') and self.topic_count is not None:
            _dict['topic_count'] = self.topic_count
        if hasattr(self, 'topic_names') and self.topic_names is not None:
            _dict['topic_names'] = self.topic_names
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Source object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Source') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Source') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SourceList():
    """
    Payload describing a source list request.

    :attr int total_count: Number of sources.
    :attr int offset: Current offset.
    :attr int limit: limit to show sources.
    :attr List[SourcesListItem] sources: List of sources.
    """

    def __init__(self,
                 total_count: int,
                 offset: int,
                 limit: int,
                 sources: List['SourcesListItem']) -> None:
        """
        Initialize a SourceList object.

        :param int total_count: Number of sources.
        :param int offset: Current offset.
        :param int limit: limit to show sources.
        :param List[SourcesListItem] sources: List of sources.
        """
        self.total_count = total_count
        self.offset = offset
        self.limit = limit
        self.sources = sources

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SourceList':
        """Initialize a SourceList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SourceList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SourceList JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SourceList JSON')
        if 'sources' in _dict:
            args['sources'] = [SourcesListItem.from_dict(x) for x in _dict.get('sources')]
        else:
            raise ValueError('Required property \'sources\' not present in SourceList JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SourceList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'sources') and self.sources is not None:
            _dict['sources'] = [x.to_dict() for x in self.sources]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SourceList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SourceList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SourceList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SourcesListItem():
    """
    Payload describing a source list item.

    :attr str id: ID of the source.
    :attr str name: Name of the source.
    :attr str description: Description of the source.
    :attr str type: Type of the source.
    :attr bool enabled: Whether the source is enabled or not.
    :attr datetime updated_at: Time of the last update.
    :attr int topic_count: Number of topics.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 type: str,
                 enabled: bool,
                 updated_at: datetime,
                 topic_count: int) -> None:
        """
        Initialize a SourcesListItem object.

        :param str id: ID of the source.
        :param str name: Name of the source.
        :param str description: Description of the source.
        :param str type: Type of the source.
        :param bool enabled: Whether the source is enabled or not.
        :param datetime updated_at: Time of the last update.
        :param int topic_count: Number of topics.
        """
        self.id = id
        self.name = name
        self.description = description
        self.type = type
        self.enabled = enabled
        self.updated_at = updated_at
        self.topic_count = topic_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SourcesListItem':
        """Initialize a SourcesListItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in SourcesListItem JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SourcesListItem JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in SourcesListItem JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in SourcesListItem JSON')
        if 'enabled' in _dict:
            args['enabled'] = _dict.get('enabled')
        else:
            raise ValueError('Required property \'enabled\' not present in SourcesListItem JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SourcesListItem JSON')
        if 'topic_count' in _dict:
            args['topic_count'] = _dict.get('topic_count')
        else:
            raise ValueError('Required property \'topic_count\' not present in SourcesListItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SourcesListItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'enabled') and self.enabled is not None:
            _dict['enabled'] = self.enabled
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'topic_count') and self.topic_count is not None:
            _dict['topic_count'] = self.topic_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SourcesListItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SourcesListItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SourcesListItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Subscription():
    """
    Subscription object.

    :attr str id: Subscription ID.
    :attr str name: Subscription name.
    :attr str description: Subscription description.
    :attr str updated_at: Last updated time.
    :attr str from_: (optional) From Email ID (it will be displayed only in case of
          smtp_ibm destination type).
    :attr str destination_type: The type of destination.
    :attr str destination_id: The destination ID.
    :attr str destination_name: The destination name.
    :attr str topic_id: Topic ID.
    :attr str topic_name: Topic name.
    :attr SubscriptionAttributes attributes:
    """

    # The set of defined properties for the class
    _properties = frozenset(['id', 'name', 'description', 'updated_at', 'from_', 'from', 'destination_type', 'destination_id', 'destination_name', 'topic_id', 'topic_name', 'attributes'])

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 updated_at: str,
                 destination_type: str,
                 destination_id: str,
                 destination_name: str,
                 topic_id: str,
                 topic_name: str,
                 attributes: 'SubscriptionAttributes',
                 *,
                 from_: str = None,
                 **kwargs) -> None:
        """
        Initialize a Subscription object.

        :param str id: Subscription ID.
        :param str name: Subscription name.
        :param str description: Subscription description.
        :param str updated_at: Last updated time.
        :param str destination_type: The type of destination.
        :param str destination_id: The destination ID.
        :param str destination_name: The destination name.
        :param str topic_id: Topic ID.
        :param str topic_name: Topic name.
        :param SubscriptionAttributes attributes:
        :param str from_: (optional) From Email ID (it will be displayed only in
               case of smtp_ibm destination type).
        :param **kwargs: (optional) Any additional properties.
        """
        self.id = id
        self.name = name
        self.description = description
        self.updated_at = updated_at
        self.from_ = from_
        self.destination_type = destination_type
        self.destination_id = destination_id
        self.destination_name = destination_name
        self.topic_id = topic_id
        self.topic_name = topic_name
        self.attributes = attributes
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Subscription':
        """Initialize a Subscription object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in Subscription JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Subscription JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in Subscription JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = _dict.get('updated_at')
        else:
            raise ValueError('Required property \'updated_at\' not present in Subscription JSON')
        if 'from' in _dict:
            args['from_'] = _dict.get('from')
        if 'destination_type' in _dict:
            args['destination_type'] = _dict.get('destination_type')
        else:
            raise ValueError('Required property \'destination_type\' not present in Subscription JSON')
        if 'destination_id' in _dict:
            args['destination_id'] = _dict.get('destination_id')
        else:
            raise ValueError('Required property \'destination_id\' not present in Subscription JSON')
        if 'destination_name' in _dict:
            args['destination_name'] = _dict.get('destination_name')
        else:
            raise ValueError('Required property \'destination_name\' not present in Subscription JSON')
        if 'topic_id' in _dict:
            args['topic_id'] = _dict.get('topic_id')
        else:
            raise ValueError('Required property \'topic_id\' not present in Subscription JSON')
        if 'topic_name' in _dict:
            args['topic_name'] = _dict.get('topic_name')
        else:
            raise ValueError('Required property \'topic_name\' not present in Subscription JSON')
        if 'attributes' in _dict:
            args['attributes'] = _dict.get('attributes')
        else:
            raise ValueError('Required property \'attributes\' not present in Subscription JSON')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Subscription object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = self.updated_at
        if hasattr(self, 'from_') and self.from_ is not None:
            _dict['from'] = self.from_
        if hasattr(self, 'destination_type') and self.destination_type is not None:
            _dict['destination_type'] = self.destination_type
        if hasattr(self, 'destination_id') and self.destination_id is not None:
            _dict['destination_id'] = self.destination_id
        if hasattr(self, 'destination_name') and self.destination_name is not None:
            _dict['destination_name'] = self.destination_name
        if hasattr(self, 'topic_id') and self.topic_id is not None:
            _dict['topic_id'] = self.topic_id
        if hasattr(self, 'topic_name') and self.topic_name is not None:
            _dict['topic_name'] = self.topic_name
        if hasattr(self, 'attributes') and self.attributes is not None:
            if isinstance(self.attributes, dict):
                _dict['attributes'] = self.attributes
            else:
                _dict['attributes'] = self.attributes.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Subscription._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def get_properties(self) -> Dict:
        """Return a dictionary of arbitrary properties from this instance of Subscription"""
        _dict = {}

        for _key in [k for k in vars(self).keys() if k not in Subscription._properties]:
            _dict[_key] = getattr(self, _key)
        return _dict

    def set_properties(self, _dict: dict):
        """Set a dictionary of arbitrary properties to this instance of Subscription"""
        for _key in [k for k in vars(self).keys() if k not in Subscription._properties]:
            delattr(self, _key)

        for _key, _value in _dict.items():
            if _key not in Subscription._properties:
                setattr(self, _key, _value)

    def __str__(self) -> str:
        """Return a `str` version of this Subscription object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Subscription') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Subscription') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class DestinationTypeEnum(str, Enum):
        """
        The type of destination.
        """
        SMS_IBM = 'sms_ibm'
        SMTP_IBM = 'smtp_ibm'
        WEBHOOK = 'webhook'


class SubscriptionAttributes():
    """
    SubscriptionAttributes.

    """

    def __init__(self) -> None:
        """
        Initialize a SubscriptionAttributes object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
                  ", ".join(['SubscriptionAttributesSMSAttributesResponse', 'SubscriptionAttributesEmailAttributesResponse', 'SubscriptionAttributesWebhookAttributesResponse']))
        raise Exception(msg)

class SubscriptionCreateAttributes():
    """
    SubscriptionCreateAttributes.

    """

    def __init__(self) -> None:
        """
        Initialize a SubscriptionCreateAttributes object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
                  ", ".join(['SubscriptionCreateAttributesSMSAttributes', 'SubscriptionCreateAttributesEmailAttributes', 'SubscriptionCreateAttributesWebhookAttributes']))
        raise Exception(msg)

class SubscriptionList():
    """
    Subscription list object.

    :attr int total_count: Number of subscriptions.
    :attr int offset: Current offset.
    :attr int limit: limit to show subscriptions.
    :attr List[SubscriptionListItem] subscriptions: List of subscriptions.
    """

    def __init__(self,
                 total_count: int,
                 offset: int,
                 limit: int,
                 subscriptions: List['SubscriptionListItem']) -> None:
        """
        Initialize a SubscriptionList object.

        :param int total_count: Number of subscriptions.
        :param int offset: Current offset.
        :param int limit: limit to show subscriptions.
        :param List[SubscriptionListItem] subscriptions: List of subscriptions.
        """
        self.total_count = total_count
        self.offset = offset
        self.limit = limit
        self.subscriptions = subscriptions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionList':
        """Initialize a SubscriptionList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SubscriptionList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SubscriptionList JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SubscriptionList JSON')
        if 'subscriptions' in _dict:
            args['subscriptions'] = [SubscriptionListItem.from_dict(x) for x in _dict.get('subscriptions')]
        else:
            raise ValueError('Required property \'subscriptions\' not present in SubscriptionList JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'subscriptions') and self.subscriptions is not None:
            _dict['subscriptions'] = [x.to_dict() for x in self.subscriptions]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionListItem():
    """
    Subscription list item.

    :attr str id: ID of the subscription.
    :attr str name: Name of the subscription.
    :attr str description: Description of the subscription.
    :attr str destination_id: ID of the destination.
    :attr str destination_name: (optional) Name of the destination.
    :attr str destination_type: The type of destination.
    :attr str topic_id: ID of the topic.
    :attr str topic_name: (optional) Name of the topic.
    :attr datetime updated_at: Last updated time of the subscription.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 destination_id: str,
                 destination_type: str,
                 topic_id: str,
                 updated_at: datetime,
                 *,
                 destination_name: str = None,
                 topic_name: str = None) -> None:
        """
        Initialize a SubscriptionListItem object.

        :param str id: ID of the subscription.
        :param str name: Name of the subscription.
        :param str description: Description of the subscription.
        :param str destination_id: ID of the destination.
        :param str destination_type: The type of destination.
        :param str topic_id: ID of the topic.
        :param datetime updated_at: Last updated time of the subscription.
        :param str destination_name: (optional) Name of the destination.
        :param str topic_name: (optional) Name of the topic.
        """
        self.id = id
        self.name = name
        self.description = description
        self.destination_id = destination_id
        self.destination_name = destination_name
        self.destination_type = destination_type
        self.topic_id = topic_id
        self.topic_name = topic_name
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionListItem':
        """Initialize a SubscriptionListItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in SubscriptionListItem JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SubscriptionListItem JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in SubscriptionListItem JSON')
        if 'destination_id' in _dict:
            args['destination_id'] = _dict.get('destination_id')
        else:
            raise ValueError('Required property \'destination_id\' not present in SubscriptionListItem JSON')
        if 'destination_name' in _dict:
            args['destination_name'] = _dict.get('destination_name')
        if 'destination_type' in _dict:
            args['destination_type'] = _dict.get('destination_type')
        else:
            raise ValueError('Required property \'destination_type\' not present in SubscriptionListItem JSON')
        if 'topic_id' in _dict:
            args['topic_id'] = _dict.get('topic_id')
        else:
            raise ValueError('Required property \'topic_id\' not present in SubscriptionListItem JSON')
        if 'topic_name' in _dict:
            args['topic_name'] = _dict.get('topic_name')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SubscriptionListItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionListItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'destination_id') and self.destination_id is not None:
            _dict['destination_id'] = self.destination_id
        if hasattr(self, 'destination_name') and self.destination_name is not None:
            _dict['destination_name'] = self.destination_name
        if hasattr(self, 'destination_type') and self.destination_type is not None:
            _dict['destination_type'] = self.destination_type
        if hasattr(self, 'topic_id') and self.topic_id is not None:
            _dict['topic_id'] = self.topic_id
        if hasattr(self, 'topic_name') and self.topic_name is not None:
            _dict['topic_name'] = self.topic_name
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionListItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionListItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionListItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class DestinationTypeEnum(str, Enum):
        """
        The type of destination.
        """
        SMS_IBM = 'sms_ibm'
        SMTP_IBM = 'smtp_ibm'
        WEBHOOK = 'webhook'


class SubscriptionUpdateAttributes():
    """
    SubscriptionUpdateAttributes.

    """

    def __init__(self) -> None:
        """
        Initialize a SubscriptionUpdateAttributes object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
                  ", ".join(['SubscriptionUpdateAttributesSMSAttributes', 'SubscriptionUpdateAttributesEmailAttributes', 'SubscriptionUpdateAttributesWebhookAttributes']))
        raise Exception(msg)

class Topic():
    """
    Topic object.

    :attr str id: Autogenerated topic ID.
    :attr str description: Description of the topic.
    :attr str name: Name of the topic.
    :attr str updated_at: Last time the topic was updated.
    :attr int source_count: Number of sources.
    :attr List[TopicSourcesItem] sources: List of sources.
    :attr int subscription_count: Number of subscriptions.
    :attr List[SubscriptionListItem] subscriptions: List of subscriptions.
    """

    def __init__(self,
                 id: str,
                 description: str,
                 name: str,
                 updated_at: str,
                 source_count: int,
                 sources: List['TopicSourcesItem'],
                 subscription_count: int,
                 subscriptions: List['SubscriptionListItem']) -> None:
        """
        Initialize a Topic object.

        :param str id: Autogenerated topic ID.
        :param str description: Description of the topic.
        :param str name: Name of the topic.
        :param str updated_at: Last time the topic was updated.
        :param int source_count: Number of sources.
        :param List[TopicSourcesItem] sources: List of sources.
        :param int subscription_count: Number of subscriptions.
        :param List[SubscriptionListItem] subscriptions: List of subscriptions.
        """
        self.id = id
        self.description = description
        self.name = name
        self.updated_at = updated_at
        self.source_count = source_count
        self.sources = sources
        self.subscription_count = subscription_count
        self.subscriptions = subscriptions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Topic':
        """Initialize a Topic object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in Topic JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in Topic JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Topic JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = _dict.get('updated_at')
        else:
            raise ValueError('Required property \'updated_at\' not present in Topic JSON')
        if 'source_count' in _dict:
            args['source_count'] = _dict.get('source_count')
        else:
            raise ValueError('Required property \'source_count\' not present in Topic JSON')
        if 'sources' in _dict:
            args['sources'] = [TopicSourcesItem.from_dict(x) for x in _dict.get('sources')]
        else:
            raise ValueError('Required property \'sources\' not present in Topic JSON')
        if 'subscription_count' in _dict:
            args['subscription_count'] = _dict.get('subscription_count')
        else:
            raise ValueError('Required property \'subscription_count\' not present in Topic JSON')
        if 'subscriptions' in _dict:
            args['subscriptions'] = [SubscriptionListItem.from_dict(x) for x in _dict.get('subscriptions')]
        else:
            raise ValueError('Required property \'subscriptions\' not present in Topic JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Topic object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = self.updated_at
        if hasattr(self, 'source_count') and self.source_count is not None:
            _dict['source_count'] = self.source_count
        if hasattr(self, 'sources') and self.sources is not None:
            _dict['sources'] = [x.to_dict() for x in self.sources]
        if hasattr(self, 'subscription_count') and self.subscription_count is not None:
            _dict['subscription_count'] = self.subscription_count
        if hasattr(self, 'subscriptions') and self.subscriptions is not None:
            _dict['subscriptions'] = [x.to_dict() for x in self.subscriptions]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Topic object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Topic') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Topic') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TopicList():
    """
    Topic list object.

    :attr int total_count: Number of topics.
    :attr int offset: Current offset.
    :attr int limit: limit to show subscriptions.
    :attr List[TopicsListItem] topics: List of topics.
    """

    def __init__(self,
                 total_count: int,
                 offset: int,
                 limit: int,
                 topics: List['TopicsListItem']) -> None:
        """
        Initialize a TopicList object.

        :param int total_count: Number of topics.
        :param int offset: Current offset.
        :param int limit: limit to show subscriptions.
        :param List[TopicsListItem] topics: List of topics.
        """
        self.total_count = total_count
        self.offset = offset
        self.limit = limit
        self.topics = topics

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TopicList':
        """Initialize a TopicList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in TopicList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in TopicList JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TopicList JSON')
        if 'topics' in _dict:
            args['topics'] = [TopicsListItem.from_dict(x) for x in _dict.get('topics')]
        else:
            raise ValueError('Required property \'topics\' not present in TopicList JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TopicList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'topics') and self.topics is not None:
            _dict['topics'] = [x.to_dict() for x in self.topics]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TopicList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TopicList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TopicList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TopicResponse():
    """
    Topic object.

    :attr str id: Autogenerated topic ID.
    :attr str name: Name of the topic.
    :attr str description: Description of the topic.
    :attr str created_at: Last time the topic was updated.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 created_at: str) -> None:
        """
        Initialize a TopicResponse object.

        :param str id: Autogenerated topic ID.
        :param str name: Name of the topic.
        :param str description: Description of the topic.
        :param str created_at: Last time the topic was updated.
        """
        self.id = id
        self.name = name
        self.description = description
        self.created_at = created_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TopicResponse':
        """Initialize a TopicResponse object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TopicResponse JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TopicResponse JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in TopicResponse JSON')
        if 'created_at' in _dict:
            args['created_at'] = _dict.get('created_at')
        else:
            raise ValueError('Required property \'created_at\' not present in TopicResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TopicResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = self.created_at
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TopicResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TopicResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TopicResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TopicSourcesItem():
    """
    TopicSourcesItem.

    :attr str id: ID of the source.
    :attr str name: Name of the source.
    :attr List[RulesGet] rules: List of rules.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 rules: List['RulesGet']) -> None:
        """
        Initialize a TopicSourcesItem object.

        :param str id: ID of the source.
        :param str name: Name of the source.
        :param List[RulesGet] rules: List of rules.
        """
        self.id = id
        self.name = name
        self.rules = rules

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TopicSourcesItem':
        """Initialize a TopicSourcesItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TopicSourcesItem JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TopicSourcesItem JSON')
        if 'rules' in _dict:
            args['rules'] = [RulesGet.from_dict(x) for x in _dict.get('rules')]
        else:
            raise ValueError('Required property \'rules\' not present in TopicSourcesItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TopicSourcesItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'rules') and self.rules is not None:
            _dict['rules'] = [x.to_dict() for x in self.rules]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TopicSourcesItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TopicSourcesItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TopicSourcesItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TopicUpdateSourcesItem():
    """
    TopicUpdateSourcesItem.

    :attr str id: ID of the source.
    :attr List[Rules] rules: List of rules.
    """

    def __init__(self,
                 id: str,
                 rules: List['Rules']) -> None:
        """
        Initialize a TopicUpdateSourcesItem object.

        :param str id: ID of the source.
        :param List[Rules] rules: List of rules.
        """
        self.id = id
        self.rules = rules

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TopicUpdateSourcesItem':
        """Initialize a TopicUpdateSourcesItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TopicUpdateSourcesItem JSON')
        if 'rules' in _dict:
            args['rules'] = [Rules.from_dict(x) for x in _dict.get('rules')]
        else:
            raise ValueError('Required property \'rules\' not present in TopicUpdateSourcesItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TopicUpdateSourcesItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'rules') and self.rules is not None:
            _dict['rules'] = [x.to_dict() for x in self.rules]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TopicUpdateSourcesItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TopicUpdateSourcesItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TopicUpdateSourcesItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TopicsListItem():
    """
    Topic list item object.

    :attr str id: Autogenerated topic ID.
    :attr str name: Name of the topic.
    :attr str description: Description of the topic.
    :attr int source_count: Number of sources.
    :attr List[str] sources_names: List of source names.
    :attr int subscription_count: Number of subscriptions.
    """

    def __init__(self,
                 id: str,
                 name: str,
                 description: str,
                 source_count: int,
                 sources_names: List[str],
                 subscription_count: int) -> None:
        """
        Initialize a TopicsListItem object.

        :param str id: Autogenerated topic ID.
        :param str name: Name of the topic.
        :param str description: Description of the topic.
        :param int source_count: Number of sources.
        :param List[str] sources_names: List of source names.
        :param int subscription_count: Number of subscriptions.
        """
        self.id = id
        self.name = name
        self.description = description
        self.source_count = source_count
        self.sources_names = sources_names
        self.subscription_count = subscription_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TopicsListItem':
        """Initialize a TopicsListItem object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in TopicsListItem JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in TopicsListItem JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in TopicsListItem JSON')
        if 'source_count' in _dict:
            args['source_count'] = _dict.get('source_count')
        else:
            raise ValueError('Required property \'source_count\' not present in TopicsListItem JSON')
        if 'sources_names' in _dict:
            args['sources_names'] = _dict.get('sources_names')
        else:
            raise ValueError('Required property \'sources_names\' not present in TopicsListItem JSON')
        if 'subscription_count' in _dict:
            args['subscription_count'] = _dict.get('subscription_count')
        else:
            raise ValueError('Required property \'subscription_count\' not present in TopicsListItem JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TopicsListItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'source_count') and self.source_count is not None:
            _dict['source_count'] = self.source_count
        if hasattr(self, 'sources_names') and self.sources_names is not None:
            _dict['sources_names'] = self.sources_names
        if hasattr(self, 'subscription_count') and self.subscription_count is not None:
            _dict['subscription_count'] = self.subscription_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TopicsListItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TopicsListItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TopicsListItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DestinationConfigParamsWebhookDestinationConfig(DestinationConfigParams):
    """
    Payload describing a webhook destination configuration.

    :attr str url: URL of webhook.
    :attr str verb: HTTP method of webhook.
    :attr dict custom_headers: (optional) Custom headers (Key-Value pair) for
          webhook call.
    :attr List[str] sensitive_headers: (optional) List of sensitive headers from
          custom headers.
    """

    def __init__(self,
                 url: str,
                 verb: str,
                 *,
                 custom_headers: dict = None,
                 sensitive_headers: List[str] = None) -> None:
        """
        Initialize a DestinationConfigParamsWebhookDestinationConfig object.

        :param str url: URL of webhook.
        :param str verb: HTTP method of webhook.
        :param dict custom_headers: (optional) Custom headers (Key-Value pair) for
               webhook call.
        :param List[str] sensitive_headers: (optional) List of sensitive headers
               from custom headers.
        """
        # pylint: disable=super-init-not-called
        self.url = url
        self.verb = verb
        self.custom_headers = custom_headers
        self.sensitive_headers = sensitive_headers

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DestinationConfigParamsWebhookDestinationConfig':
        """Initialize a DestinationConfigParamsWebhookDestinationConfig object from a json dictionary."""
        args = {}
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        else:
            raise ValueError('Required property \'url\' not present in DestinationConfigParamsWebhookDestinationConfig JSON')
        if 'verb' in _dict:
            args['verb'] = _dict.get('verb')
        else:
            raise ValueError('Required property \'verb\' not present in DestinationConfigParamsWebhookDestinationConfig JSON')
        if 'custom_headers' in _dict:
            args['custom_headers'] = _dict.get('custom_headers')
        if 'sensitive_headers' in _dict:
            args['sensitive_headers'] = _dict.get('sensitive_headers')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DestinationConfigParamsWebhookDestinationConfig object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        if hasattr(self, 'verb') and self.verb is not None:
            _dict['verb'] = self.verb
        if hasattr(self, 'custom_headers') and self.custom_headers is not None:
            _dict['custom_headers'] = self.custom_headers
        if hasattr(self, 'sensitive_headers') and self.sensitive_headers is not None:
            _dict['sensitive_headers'] = self.sensitive_headers
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DestinationConfigParamsWebhookDestinationConfig object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DestinationConfigParamsWebhookDestinationConfig') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DestinationConfigParamsWebhookDestinationConfig') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class VerbEnum(str, Enum):
        """
        HTTP method of webhook.
        """
        GET = 'get'
        POST = 'post'


class SubscriptionAttributesEmailAttributesResponse(SubscriptionAttributes):
    """
    The attributes for an email notification.

    :attr List[str] to: The email id string.
    :attr bool add_notification_payload: Whether to add the notification payload to
          the email.
    :attr str reply_to_mail: The email address to reply to.
    :attr str reply_to_name: The email name to reply to.
    :attr str from_name: The email name of From.
    """

    def __init__(self,
                 to: List[str],
                 add_notification_payload: bool,
                 reply_to_mail: str,
                 reply_to_name: str,
                 from_name: str) -> None:
        """
        Initialize a SubscriptionAttributesEmailAttributesResponse object.

        :param List[str] to: The email id string.
        :param bool add_notification_payload: Whether to add the notification
               payload to the email.
        :param str reply_to_mail: The email address to reply to.
        :param str reply_to_name: The email name to reply to.
        :param str from_name: The email name of From.
        """
        # pylint: disable=super-init-not-called
        self.to = to
        self.add_notification_payload = add_notification_payload
        self.reply_to_mail = reply_to_mail
        self.reply_to_name = reply_to_name
        self.from_name = from_name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionAttributesEmailAttributesResponse':
        """Initialize a SubscriptionAttributesEmailAttributesResponse object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionAttributesEmailAttributesResponse JSON')
        if 'add_notification_payload' in _dict:
            args['add_notification_payload'] = _dict.get('add_notification_payload')
        else:
            raise ValueError('Required property \'add_notification_payload\' not present in SubscriptionAttributesEmailAttributesResponse JSON')
        if 'reply_to_mail' in _dict:
            args['reply_to_mail'] = _dict.get('reply_to_mail')
        else:
            raise ValueError('Required property \'reply_to_mail\' not present in SubscriptionAttributesEmailAttributesResponse JSON')
        if 'reply_to_name' in _dict:
            args['reply_to_name'] = _dict.get('reply_to_name')
        else:
            raise ValueError('Required property \'reply_to_name\' not present in SubscriptionAttributesEmailAttributesResponse JSON')
        if 'from_name' in _dict:
            args['from_name'] = _dict.get('from_name')
        else:
            raise ValueError('Required property \'from_name\' not present in SubscriptionAttributesEmailAttributesResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionAttributesEmailAttributesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        if hasattr(self, 'add_notification_payload') and self.add_notification_payload is not None:
            _dict['add_notification_payload'] = self.add_notification_payload
        if hasattr(self, 'reply_to_mail') and self.reply_to_mail is not None:
            _dict['reply_to_mail'] = self.reply_to_mail
        if hasattr(self, 'reply_to_name') and self.reply_to_name is not None:
            _dict['reply_to_name'] = self.reply_to_name
        if hasattr(self, 'from_name') and self.from_name is not None:
            _dict['from_name'] = self.from_name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionAttributesEmailAttributesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionAttributesEmailAttributesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionAttributesEmailAttributesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionAttributesSMSAttributesResponse(SubscriptionAttributes):
    """
    SMS attributes object.

    :attr List[str] to: The phone number to send the SMS to.
    """

    def __init__(self,
                 to: List[str]) -> None:
        """
        Initialize a SubscriptionAttributesSMSAttributesResponse object.

        :param List[str] to: The phone number to send the SMS to.
        """
        # pylint: disable=super-init-not-called
        self.to = to

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionAttributesSMSAttributesResponse':
        """Initialize a SubscriptionAttributesSMSAttributesResponse object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionAttributesSMSAttributesResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionAttributesSMSAttributesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionAttributesSMSAttributesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionAttributesSMSAttributesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionAttributesSMSAttributesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionAttributesWebhookAttributesResponse(SubscriptionAttributes):
    """
    The attributes for a webhook notification.

    :attr bool signing_enabled: Signing webhook attributes.
    :attr bool add_notification_payload: Decision for Notification Payload to be
          added.
    """

    def __init__(self,
                 signing_enabled: bool,
                 add_notification_payload: bool) -> None:
        """
        Initialize a SubscriptionAttributesWebhookAttributesResponse object.

        :param bool signing_enabled: Signing webhook attributes.
        :param bool add_notification_payload: Decision for Notification Payload to
               be added.
        """
        # pylint: disable=super-init-not-called
        self.signing_enabled = signing_enabled
        self.add_notification_payload = add_notification_payload

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionAttributesWebhookAttributesResponse':
        """Initialize a SubscriptionAttributesWebhookAttributesResponse object from a json dictionary."""
        args = {}
        if 'signing_enabled' in _dict:
            args['signing_enabled'] = _dict.get('signing_enabled')
        else:
            raise ValueError('Required property \'signing_enabled\' not present in SubscriptionAttributesWebhookAttributesResponse JSON')
        if 'add_notification_payload' in _dict:
            args['add_notification_payload'] = _dict.get('add_notification_payload')
        else:
            raise ValueError('Required property \'add_notification_payload\' not present in SubscriptionAttributesWebhookAttributesResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionAttributesWebhookAttributesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'signing_enabled') and self.signing_enabled is not None:
            _dict['signing_enabled'] = self.signing_enabled
        if hasattr(self, 'add_notification_payload') and self.add_notification_payload is not None:
            _dict['add_notification_payload'] = self.add_notification_payload
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionAttributesWebhookAttributesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionAttributesWebhookAttributesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionAttributesWebhookAttributesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionCreateAttributesEmailAttributes(SubscriptionCreateAttributes):
    """
    The attributes for an email notification.

    :attr List[str] to: The email id string.
    :attr bool add_notification_payload: Whether to add the notification payload to
          the email.
    :attr str reply_to_mail: The email address to reply to.
    :attr str reply_to_name: The email name to reply to.
    :attr str from_name: The email name of From.
    """

    def __init__(self,
                 to: List[str],
                 add_notification_payload: bool,
                 reply_to_mail: str,
                 reply_to_name: str,
                 from_name: str) -> None:
        """
        Initialize a SubscriptionCreateAttributesEmailAttributes object.

        :param List[str] to: The email id string.
        :param bool add_notification_payload: Whether to add the notification
               payload to the email.
        :param str reply_to_mail: The email address to reply to.
        :param str reply_to_name: The email name to reply to.
        :param str from_name: The email name of From.
        """
        # pylint: disable=super-init-not-called
        self.to = to
        self.add_notification_payload = add_notification_payload
        self.reply_to_mail = reply_to_mail
        self.reply_to_name = reply_to_name
        self.from_name = from_name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionCreateAttributesEmailAttributes':
        """Initialize a SubscriptionCreateAttributesEmailAttributes object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionCreateAttributesEmailAttributes JSON')
        if 'add_notification_payload' in _dict:
            args['add_notification_payload'] = _dict.get('add_notification_payload')
        else:
            raise ValueError('Required property \'add_notification_payload\' not present in SubscriptionCreateAttributesEmailAttributes JSON')
        if 'reply_to_mail' in _dict:
            args['reply_to_mail'] = _dict.get('reply_to_mail')
        else:
            raise ValueError('Required property \'reply_to_mail\' not present in SubscriptionCreateAttributesEmailAttributes JSON')
        if 'reply_to_name' in _dict:
            args['reply_to_name'] = _dict.get('reply_to_name')
        else:
            raise ValueError('Required property \'reply_to_name\' not present in SubscriptionCreateAttributesEmailAttributes JSON')
        if 'from_name' in _dict:
            args['from_name'] = _dict.get('from_name')
        else:
            raise ValueError('Required property \'from_name\' not present in SubscriptionCreateAttributesEmailAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionCreateAttributesEmailAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        if hasattr(self, 'add_notification_payload') and self.add_notification_payload is not None:
            _dict['add_notification_payload'] = self.add_notification_payload
        if hasattr(self, 'reply_to_mail') and self.reply_to_mail is not None:
            _dict['reply_to_mail'] = self.reply_to_mail
        if hasattr(self, 'reply_to_name') and self.reply_to_name is not None:
            _dict['reply_to_name'] = self.reply_to_name
        if hasattr(self, 'from_name') and self.from_name is not None:
            _dict['from_name'] = self.from_name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionCreateAttributesEmailAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionCreateAttributesEmailAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionCreateAttributesEmailAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionCreateAttributesSMSAttributes(SubscriptionCreateAttributes):
    """
    SMS attributes object.

    :attr List[str] to: The phone number to send the SMS to.
    """

    def __init__(self,
                 to: List[str]) -> None:
        """
        Initialize a SubscriptionCreateAttributesSMSAttributes object.

        :param List[str] to: The phone number to send the SMS to.
        """
        # pylint: disable=super-init-not-called
        self.to = to

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionCreateAttributesSMSAttributes':
        """Initialize a SubscriptionCreateAttributesSMSAttributes object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionCreateAttributesSMSAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionCreateAttributesSMSAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionCreateAttributesSMSAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionCreateAttributesSMSAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionCreateAttributesSMSAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionCreateAttributesWebhookAttributes(SubscriptionCreateAttributes):
    """
    The attributes for a webhook notification.

    :attr bool signing_enabled: Signing webhook attributes.
    """

    def __init__(self,
                 signing_enabled: bool) -> None:
        """
        Initialize a SubscriptionCreateAttributesWebhookAttributes object.

        :param bool signing_enabled: Signing webhook attributes.
        """
        # pylint: disable=super-init-not-called
        self.signing_enabled = signing_enabled

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionCreateAttributesWebhookAttributes':
        """Initialize a SubscriptionCreateAttributesWebhookAttributes object from a json dictionary."""
        args = {}
        if 'signing_enabled' in _dict:
            args['signing_enabled'] = _dict.get('signing_enabled')
        else:
            raise ValueError('Required property \'signing_enabled\' not present in SubscriptionCreateAttributesWebhookAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionCreateAttributesWebhookAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'signing_enabled') and self.signing_enabled is not None:
            _dict['signing_enabled'] = self.signing_enabled
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionCreateAttributesWebhookAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionCreateAttributesWebhookAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionCreateAttributesWebhookAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionUpdateAttributesEmailAttributes(SubscriptionUpdateAttributes):
    """
    The attributes for an email notification.

    :attr List[str] to: The email id string.
    :attr bool add_notification_payload: Whether to add the notification payload to
          the email.
    :attr str reply_to_mail: The email address to reply to.
    :attr str reply_to_name: The email name to reply to.
    :attr str from_name: The email name of From.
    """

    def __init__(self,
                 to: List[str],
                 add_notification_payload: bool,
                 reply_to_mail: str,
                 reply_to_name: str,
                 from_name: str) -> None:
        """
        Initialize a SubscriptionUpdateAttributesEmailAttributes object.

        :param List[str] to: The email id string.
        :param bool add_notification_payload: Whether to add the notification
               payload to the email.
        :param str reply_to_mail: The email address to reply to.
        :param str reply_to_name: The email name to reply to.
        :param str from_name: The email name of From.
        """
        # pylint: disable=super-init-not-called
        self.to = to
        self.add_notification_payload = add_notification_payload
        self.reply_to_mail = reply_to_mail
        self.reply_to_name = reply_to_name
        self.from_name = from_name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionUpdateAttributesEmailAttributes':
        """Initialize a SubscriptionUpdateAttributesEmailAttributes object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionUpdateAttributesEmailAttributes JSON')
        if 'add_notification_payload' in _dict:
            args['add_notification_payload'] = _dict.get('add_notification_payload')
        else:
            raise ValueError('Required property \'add_notification_payload\' not present in SubscriptionUpdateAttributesEmailAttributes JSON')
        if 'reply_to_mail' in _dict:
            args['reply_to_mail'] = _dict.get('reply_to_mail')
        else:
            raise ValueError('Required property \'reply_to_mail\' not present in SubscriptionUpdateAttributesEmailAttributes JSON')
        if 'reply_to_name' in _dict:
            args['reply_to_name'] = _dict.get('reply_to_name')
        else:
            raise ValueError('Required property \'reply_to_name\' not present in SubscriptionUpdateAttributesEmailAttributes JSON')
        if 'from_name' in _dict:
            args['from_name'] = _dict.get('from_name')
        else:
            raise ValueError('Required property \'from_name\' not present in SubscriptionUpdateAttributesEmailAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionUpdateAttributesEmailAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        if hasattr(self, 'add_notification_payload') and self.add_notification_payload is not None:
            _dict['add_notification_payload'] = self.add_notification_payload
        if hasattr(self, 'reply_to_mail') and self.reply_to_mail is not None:
            _dict['reply_to_mail'] = self.reply_to_mail
        if hasattr(self, 'reply_to_name') and self.reply_to_name is not None:
            _dict['reply_to_name'] = self.reply_to_name
        if hasattr(self, 'from_name') and self.from_name is not None:
            _dict['from_name'] = self.from_name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionUpdateAttributesEmailAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionUpdateAttributesEmailAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionUpdateAttributesEmailAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionUpdateAttributesSMSAttributes(SubscriptionUpdateAttributes):
    """
    SMS attributes object.

    :attr List[str] to: The phone number to send the SMS to.
    """

    def __init__(self,
                 to: List[str]) -> None:
        """
        Initialize a SubscriptionUpdateAttributesSMSAttributes object.

        :param List[str] to: The phone number to send the SMS to.
        """
        # pylint: disable=super-init-not-called
        self.to = to

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionUpdateAttributesSMSAttributes':
        """Initialize a SubscriptionUpdateAttributesSMSAttributes object from a json dictionary."""
        args = {}
        if 'to' in _dict:
            args['to'] = _dict.get('to')
        else:
            raise ValueError('Required property \'to\' not present in SubscriptionUpdateAttributesSMSAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionUpdateAttributesSMSAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'to') and self.to is not None:
            _dict['to'] = self.to
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionUpdateAttributesSMSAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionUpdateAttributesSMSAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionUpdateAttributesSMSAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SubscriptionUpdateAttributesWebhookAttributes(SubscriptionUpdateAttributes):
    """
    The attributes for a webhook notification.

    :attr bool signing_enabled: Signing webhook attributes.
    """

    def __init__(self,
                 signing_enabled: bool) -> None:
        """
        Initialize a SubscriptionUpdateAttributesWebhookAttributes object.

        :param bool signing_enabled: Signing webhook attributes.
        """
        # pylint: disable=super-init-not-called
        self.signing_enabled = signing_enabled

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SubscriptionUpdateAttributesWebhookAttributes':
        """Initialize a SubscriptionUpdateAttributesWebhookAttributes object from a json dictionary."""
        args = {}
        if 'signing_enabled' in _dict:
            args['signing_enabled'] = _dict.get('signing_enabled')
        else:
            raise ValueError('Required property \'signing_enabled\' not present in SubscriptionUpdateAttributesWebhookAttributes JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SubscriptionUpdateAttributesWebhookAttributes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'signing_enabled') and self.signing_enabled is not None:
            _dict['signing_enabled'] = self.signing_enabled
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SubscriptionUpdateAttributesWebhookAttributes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SubscriptionUpdateAttributesWebhookAttributes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SubscriptionUpdateAttributesWebhookAttributes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other
